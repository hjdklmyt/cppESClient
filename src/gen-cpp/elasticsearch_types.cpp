/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "elasticsearch_types.h"

#include <algorithm>

namespace elasticsearch { namespace thrift {

int _kMethodValues[] = {
  Method::GET,
  Method::PUT,
  Method::POST,
  Method::DELETE,
  Method::HEAD,
  Method::OPTIONS
};
const char* _kMethodNames[] = {
  "GET",
  "PUT",
  "POST",
  "DELETE",
  "HEAD",
  "OPTIONS"
};
const std::map<int, const char*> _Method_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMethodValues, _kMethodNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusValues[] = {
  Status::CONT,
  Status::SWITCHING_PROTOCOLS,
  Status::OK,
  Status::CREATED,
  Status::ACCEPTED,
  Status::NON_AUTHORITATIVE_INFORMATION,
  Status::NO_CONTENT,
  Status::RESET_CONTENT,
  Status::PARTIAL_CONTENT,
  Status::MULTI_STATUS,
  Status::MULTIPLE_CHOICES,
  Status::MOVED_PERMANENTLY,
  Status::FOUND,
  Status::SEE_OTHER,
  Status::NOT_MODIFIED,
  Status::USE_PROXY,
  Status::TEMPORARY_REDIRECT,
  Status::BAD_REQUEST,
  Status::UNAUTHORIZED,
  Status::PAYMENT_REQUIRED,
  Status::FORBIDDEN,
  Status::NOT_FOUND,
  Status::METHOD_NOT_ALLOWED,
  Status::NOT_ACCEPTABLE,
  Status::PROXY_AUTHENTICATION,
  Status::REQUEST_TIMEOUT,
  Status::CONFLICT,
  Status::GONE,
  Status::LENGTH_REQUIRED,
  Status::PRECONDITION_FAILED,
  Status::REQUEST_ENTITY_TOO_LARGE,
  Status::REQUEST_URI_TOO_LONG,
  Status::UNSUPPORTED_MEDIA_TYPE,
  Status::REQUESTED_RANGE_NOT_SATISFIED,
  Status::EXPECTATION_FAILED,
  Status::UNPROCESSABLE_ENTITY,
  Status::LOCKED,
  Status::FAILED_DEPENDENCY,
  Status::INTERNAL_SERVER_ERROR,
  Status::NOT_IMPLEMENTED,
  Status::BAD_GATEWAY,
  Status::SERVICE_UNAVAILABLE,
  Status::GATEWAY_TIMEOUT,
  Status::INSUFFICIENT_STORAGE
};
const char* _kStatusNames[] = {
  "CONT",
  "SWITCHING_PROTOCOLS",
  "OK",
  "CREATED",
  "ACCEPTED",
  "NON_AUTHORITATIVE_INFORMATION",
  "NO_CONTENT",
  "RESET_CONTENT",
  "PARTIAL_CONTENT",
  "MULTI_STATUS",
  "MULTIPLE_CHOICES",
  "MOVED_PERMANENTLY",
  "FOUND",
  "SEE_OTHER",
  "NOT_MODIFIED",
  "USE_PROXY",
  "TEMPORARY_REDIRECT",
  "BAD_REQUEST",
  "UNAUTHORIZED",
  "PAYMENT_REQUIRED",
  "FORBIDDEN",
  "NOT_FOUND",
  "METHOD_NOT_ALLOWED",
  "NOT_ACCEPTABLE",
  "PROXY_AUTHENTICATION",
  "REQUEST_TIMEOUT",
  "CONFLICT",
  "GONE",
  "LENGTH_REQUIRED",
  "PRECONDITION_FAILED",
  "REQUEST_ENTITY_TOO_LARGE",
  "REQUEST_URI_TOO_LONG",
  "UNSUPPORTED_MEDIA_TYPE",
  "REQUESTED_RANGE_NOT_SATISFIED",
  "EXPECTATION_FAILED",
  "UNPROCESSABLE_ENTITY",
  "LOCKED",
  "FAILED_DEPENDENCY",
  "INTERNAL_SERVER_ERROR",
  "NOT_IMPLEMENTED",
  "BAD_GATEWAY",
  "SERVICE_UNAVAILABLE",
  "GATEWAY_TIMEOUT",
  "INSUFFICIENT_STORAGE"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(44, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* RestRequest::ascii_fingerprint = "9A554A22D2E0B126EB0027C0FEF00D92";
const uint8_t RestRequest::binary_fingerprint[16] = {0x9A,0x55,0x4A,0x22,0xD2,0xE0,0xB1,0x26,0xEB,0x00,0x27,0xC0,0xFE,0xF0,0x0D,0x92};

uint32_t RestRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_method = false;
  bool isset_uri = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->method = (Method::type)ecast0;
          isset_method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          isset_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              std::string _key6;
              xfer += iprot->readString(_key6);
              std::string& _val7 = this->parameters[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headers.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              std::string _key13;
              xfer += iprot->readString(_key13);
              std::string& _val14 = this->headers[_key13];
              xfer += iprot->readString(_val14);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_method)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RestRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RestRequest");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter15;
      for (_iter15 = this->parameters.begin(); _iter15 != this->parameters.end(); ++_iter15)
      {
        xfer += oprot->writeString(_iter15->first);
        xfer += oprot->writeString(_iter15->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.headers) {
    xfer += oprot->writeFieldBegin("headers", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headers.size()));
      std::map<std::string, std::string> ::const_iterator _iter16;
      for (_iter16 = this->headers.begin(); _iter16 != this->headers.end(); ++_iter16)
      {
        xfer += oprot->writeString(_iter16->first);
        xfer += oprot->writeString(_iter16->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RestRequest &a, RestRequest &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.uri, b.uri);
  swap(a.parameters, b.parameters);
  swap(a.headers, b.headers);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

const char* RestResponse::ascii_fingerprint = "E25AD7563637469761C9D5018A1E29AF";
const uint8_t RestResponse::binary_fingerprint[16] = {0xE2,0x5A,0xD7,0x56,0x36,0x37,0x46,0x97,0x61,0xC9,0xD5,0x01,0x8A,0x1E,0x29,0xAF};

uint32_t RestResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->status = (Status::type)ecast17;
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headers.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              std::string _key23;
              xfer += iprot->readString(_key23);
              std::string& _val24 = this->headers[_key23];
              xfer += iprot->readString(_val24);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RestResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RestResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.headers) {
    xfer += oprot->writeFieldBegin("headers", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headers.size()));
      std::map<std::string, std::string> ::const_iterator _iter25;
      for (_iter25 = this->headers.begin(); _iter25 != this->headers.end(); ++_iter25)
      {
        xfer += oprot->writeString(_iter25->first);
        xfer += oprot->writeString(_iter25->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RestResponse &a, RestResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.headers, b.headers);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

}} // namespace
